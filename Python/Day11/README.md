### 해결해야할 과제
  
- 숫자끼리 비교하는 연산과 문자끼리 비교하는 연산 중 왜 문자끼리 비교하는 연산이 상대적으로 불리한지 이유에 대해서 정리해보고 샘플 코드를 구현해서 제출하기
---
### 아래 내용은 제 생각을 적은내용입니다 틀릴수 있으니 댓글로 지적 바랍니다. 
---
### 문자열과 정수타입 변수의 차이  
- 문자열은 문자들이 이어져 있는 형태이다.
- 문자는 아스키코드로 치환 될 수 있다 (알파벳의 경우).
- 즉, 숫자끼리의 비교는 숫자 한번의 비교로 가능하지만 문자열의 경우 문자 각각 순차적으로 전부 비교를 해야하기 때문에
- 연산의 양과 연산의 수에서 숫자의 비교가 우위를 가질 수 있다.

```Python
num1 = 12
num2 = 13

str1 = "HelloWorld"

str1_list = []
for i in range(len(str1)):
    str1_list.append(ord(str1[i]))

print(str1_list)
# 출력결과 
# [72, 101, 108, 108, 111, 87, 111, 114, 108, 100]
```

- "Helloworld" 라는 문자열은 
- 'H','e','l','l','o' ... 와 같이 문자의 연속으로 이어져있다는 것을 볼 수 있다. 
- 파이썬의 ord 함수는 문자를 10진수 유니코드로 변환해준다. (아스키코드는 유니코드보다 작은 범위이며, 아스키코드는 유니코드에 1:1 매핑되어있다(아스크넘버의 문자는 유니코드의 문자와 같다))
- 즉, 숫자끼리의 비교는 한번의 비교연산으로 가능하지만 , 문자열의 경우 문자들을 순차적으로 **전부** 비교해야한다.
- 따라서 연산의 양과 연산의 수에서 숫자의 비교가 우위를 가질 수 있다.

### time 모듈로 시간측정해보기

- 비교연산의 시간측정을 위해 time 모듈을 포함했다
- 비교 연산의 시작 전 시간을 저장하고 (start)
- 비교 연산의 끝난 후 시간을 저장하였다. (end)
- 두 수의 차를 구함으로써 연산 시간을 측정할 수 있다.
```python
import time # 시간측정을 위한 time 모듈

start = time.time()
for i in range (100000000):
    num1 = 12
    num2 = 13
    num1 == num2
end = time.time()
print(end - start)
    
    
count = 0
start = time.time()
for i in range (100000000):
    str1 = "HelloWorld"
    str2 = "HelloPython"
    str1 == str2
end = time.time()

print(end - start)
# 출력결과
# 7.894299030303955
# 7.320104598999023
```

???
- string 비교 연산이 더 빨랐다. (end와 start의 간극이 적다)
- 생각해볼점
  
  1. C/C++ 과 같이 문자열이 데이터영역 메모리 공간에 미리 할당되는게 아닐까? (파이썬은 인터프리터 언어이기 때문에 가능성은 적다고 생각했다.)
  2. 데이터 섹션에 문자열이 할당된 그 주소를 계속 참조만 하기 때문에 더 빠른 결과가 나온 것이라고 추측했다.

### 함수 안에서 선언/초기화를 통해 지역변수로 만들어보기
- 함수 내에 변수를 선언함 으로써 지역변수로 만들고
- 함수가 호출될 때 새로운 주소를 할당받고, 함수가 끝날 때 가비지 컬렉터에 의해 주소를 방출하는 형태로 실험해봤다.
```python
import time

def compare_numbers():
    num1 = 1234567890
    num2 = 1234567891
    num1 == num2
start = time.time()

for i in range(100000000):
    compare_numbers()
end = time.time()
print(end - start)

def compare_strings():
    str1 = "HelloWorld"
    str2 = "HelloPython"
    str1 == str2

start = time.time()
for i in range(100000000):
    compare_strings()
end = time.time()
print(end - start)
# 출력결과
# 11.688180685043335
# 10.789572477340698
```
- 여전히 string 비교연산이 더 빠른 이상한 현상이 지속됐다.

### 파이썬 인터닝?
- 파이썬은 OOP를 제공하기 때문에 파이썬 인터닝이라는 최적호 기법을 사용한다고 한다
- Interning 이란 이미 생성된 객체를 재사용하는 것
- 파이썬에서 제공하는 디폴트 인터닝은 다음과 같다.
  - Cpython의 경우
  - 문자열: 20자 미만의 공백을 포함하지 않는 문자열
  - 정수: -5 부터 256 사이의 정수
  - 자료출처 : 예제로배우는파이썬프로그래밍
```python
i = 10
j = 10
print(id(i), id(j), i == j) # i주소,j주소 True
  
x = 257
y = 257
print(id(x), id(y), x == y) # x주소, y주소, False

str1 = "Hello"
str2 = "Hello1"

print(id(str1) == id(str2)) # False
print(id(str1[0]) == id(str2[0])) # True
```

- 파이썬의 내부 구조를 전부 뜯어 보지 않았지만 우리가 알지 못하는 최적화 하는 방법이 존재할 것이다.
- 파이썬 인터닝도 그 일부분이며 파이썬이 워낙 하이레벨이기 때문에 성능 개선을 위한 많은 업데이트가 진행되었을 것이다.
- 확실한건 문자열비교에 는 문자 각각 비교를 한다는 것이고, C언어 기준 정수 비교 연산보다 더 비효율적이며 속도가 느릴수밖에 없다.

---

### 추가로 알게된 사실 
- == 연산자는 동일한 메모리 위치를 참조하는지를 묻는 것이 아니라고 한다.
- "is" 연산자가 두 문자열 객체가 동일한 객체인지 확인하는 연산자 이며, 이때 인코딩 프로세스를 사용하는 것 이라고 합니다.
  
- 흠... 파이썬 역시 깊게 들어가면 너무 어려워 지는 것 같습니다...
---
